import {
  require_os
} from "./chunk-AFUH2P6F.js";
import {
  require_lib
} from "./chunk-3N75ZXBT.js";
import {
  require_events,
  require_string_decoder
} from "./chunk-RVNQBPRH.js";
import {
  require_querystring
} from "./chunk-7PVYITML.js";
import {
  require_fs,
  require_path
} from "./chunk-GV6IW2D4.js";
import "./chunk-P3NJ5QUT.js";
import {
  require_stream
} from "./chunk-3WO2S37W.js";
import {
  require_crypto
} from "./chunk-UM46D54M.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS
} from "./chunk-OROXOI2D.js";

// node_modules/formidable/src/PersistentFile.js
var require_PersistentFile = __commonJS({
  "node_modules/formidable/src/PersistentFile.js"(exports, module) {
    "use strict";
    var fs = require_fs();
    var crypto = require_crypto();
    var { EventEmitter } = require_events();
    var PersistentFile = class extends EventEmitter {
      constructor({ filepath, newFilename, originalFilename, mimetype, hashAlgorithm }) {
        super();
        this.lastModifiedDate = null;
        Object.assign(this, { filepath, newFilename, originalFilename, mimetype, hashAlgorithm });
        this.size = 0;
        this._writeStream = null;
        if (typeof this.hashAlgorithm === "string") {
          this.hash = crypto.createHash(this.hashAlgorithm);
        } else {
          this.hash = null;
        }
      }
      open() {
        this._writeStream = new fs.WriteStream(this.filepath);
        this._writeStream.on("error", (err) => {
          this.emit("error", err);
        });
      }
      toJSON() {
        const json = {
          size: this.size,
          filepath: this.filepath,
          newFilename: this.newFilename,
          mimetype: this.mimetype,
          mtime: this.lastModifiedDate,
          length: this.length,
          originalFilename: this.originalFilename
        };
        if (this.hash && this.hash !== "") {
          json.hash = this.hash;
        }
        return json;
      }
      toString() {
        return `PersistentFile: ${this.newFilename}, Original: ${this.originalFilename}, Path: ${this.filepath}`;
      }
      write(buffer, cb) {
        if (this.hash) {
          this.hash.update(buffer);
        }
        if (this._writeStream.closed) {
          cb();
          return;
        }
        this._writeStream.write(buffer, () => {
          this.lastModifiedDate = /* @__PURE__ */ new Date();
          this.size += buffer.length;
          this.emit("progress", this.size);
          cb();
        });
      }
      end(cb) {
        if (this.hash) {
          this.hash = this.hash.digest("hex");
        }
        this._writeStream.end(() => {
          this.emit("end");
          cb();
        });
      }
      destroy() {
        this._writeStream.destroy();
        fs.unlink(this.filepath, () => {
        });
      }
    };
    module.exports = PersistentFile;
  }
});

// node_modules/formidable/src/VolatileFile.js
var require_VolatileFile = __commonJS({
  "node_modules/formidable/src/VolatileFile.js"(exports, module) {
    "use strict";
    var crypto = require_crypto();
    var { EventEmitter } = require_events();
    var VolatileFile = class extends EventEmitter {
      constructor({ filepath, newFilename, originalFilename, mimetype, hashAlgorithm, createFileWriteStream }) {
        super();
        this.lastModifiedDate = null;
        Object.assign(this, { filepath, newFilename, originalFilename, mimetype, hashAlgorithm, createFileWriteStream });
        this.size = 0;
        this._writeStream = null;
        if (typeof this.hashAlgorithm === "string") {
          this.hash = crypto.createHash(this.hashAlgorithm);
        } else {
          this.hash = null;
        }
      }
      open() {
        this._writeStream = this.createFileWriteStream(this);
        this._writeStream.on("error", (err) => {
          this.emit("error", err);
        });
      }
      destroy() {
        this._writeStream.destroy();
      }
      toJSON() {
        const json = {
          size: this.size,
          newFilename: this.newFilename,
          length: this.length,
          originalFilename: this.originalFilename,
          mimetype: this.mimetype
        };
        if (this.hash && this.hash !== "") {
          json.hash = this.hash;
        }
        return json;
      }
      toString() {
        return `VolatileFile: ${this.originalFilename}`;
      }
      write(buffer, cb) {
        if (this.hash) {
          this.hash.update(buffer);
        }
        if (this._writeStream.closed || this._writeStream.destroyed) {
          cb();
          return;
        }
        this._writeStream.write(buffer, () => {
          this.size += buffer.length;
          this.emit("progress", this.size);
          cb();
        });
      }
      end(cb) {
        if (this.hash) {
          this.hash = this.hash.digest("hex");
        }
        this._writeStream.end(() => {
          this.emit("end");
          cb();
        });
      }
    };
    module.exports = VolatileFile;
  }
});

// node_modules/hexoid/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  default: () => dist_default
});
function dist_default(len) {
  len = len || 16;
  var str = "", num = 0;
  return function() {
    if (!str || num === 256) {
      str = "";
      num = (1 + len) / 2 | 0;
      while (num--)
        str += HEX[256 * Math.random() | 0];
      str = str.substring(num = 0, len - 2);
    }
    return str + HEX[num++];
  };
}
var IDX, HEX;
var init_dist = __esm({
  "node_modules/hexoid/dist/index.mjs"() {
    IDX = 256;
    HEX = [];
    while (IDX--)
      HEX[IDX] = (IDX + 256).toString(16).substring(1);
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports, module) {
    module.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports, module) {
    var wrappy = require_wrappy();
    module.exports = wrappy(once);
    module.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/asap/browser-raw.js
var require_browser_raw = __commonJS({
  "node_modules/asap/browser-raw.js"(exports, module) {
    "use strict";
    module.exports = rawAsap;
    function rawAsap(task) {
      if (!queue.length) {
        requestFlush();
        flushing = true;
      }
      queue[queue.length] = task;
    }
    var queue = [];
    var flushing = false;
    var requestFlush;
    var index = 0;
    var capacity = 1024;
    function flush() {
      while (index < queue.length) {
        var currentIndex = index;
        index = index + 1;
        queue[currentIndex].call();
        if (index > capacity) {
          for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
            queue[scan] = queue[scan + index];
          }
          queue.length -= index;
          index = 0;
        }
      }
      queue.length = 0;
      index = 0;
      flushing = false;
    }
    var scope = typeof global !== "undefined" ? global : self;
    var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
    if (typeof BrowserMutationObserver === "function") {
      requestFlush = makeRequestCallFromMutationObserver(flush);
    } else {
      requestFlush = makeRequestCallFromTimer(flush);
    }
    rawAsap.requestFlush = requestFlush;
    function makeRequestCallFromMutationObserver(callback) {
      var toggle = 1;
      var observer = new BrowserMutationObserver(callback);
      var node = document.createTextNode("");
      observer.observe(node, { characterData: true });
      return function requestCall() {
        toggle = -toggle;
        node.data = toggle;
      };
    }
    function makeRequestCallFromTimer(callback) {
      return function requestCall() {
        var timeoutHandle = setTimeout(handleTimer, 0);
        var intervalHandle = setInterval(handleTimer, 50);
        function handleTimer() {
          clearTimeout(timeoutHandle);
          clearInterval(intervalHandle);
          callback();
        }
      };
    }
    rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;
  }
});

// node_modules/asap/browser-asap.js
var require_browser_asap = __commonJS({
  "node_modules/asap/browser-asap.js"(exports, module) {
    "use strict";
    var rawAsap = require_browser_raw();
    var freeTasks = [];
    var pendingErrors = [];
    var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);
    function throwFirstError() {
      if (pendingErrors.length) {
        throw pendingErrors.shift();
      }
    }
    module.exports = asap;
    function asap(task) {
      var rawTask;
      if (freeTasks.length) {
        rawTask = freeTasks.pop();
      } else {
        rawTask = new RawTask();
      }
      rawTask.task = task;
      rawAsap(rawTask);
    }
    function RawTask() {
      this.task = null;
    }
    RawTask.prototype.call = function() {
      try {
        this.task.call();
      } catch (error) {
        if (asap.onerror) {
          asap.onerror(error);
        } else {
          pendingErrors.push(error);
          requestErrorThrow();
        }
      } finally {
        this.task = null;
        freeTasks[freeTasks.length] = this;
      }
    };
  }
});

// node_modules/dezalgo/dezalgo.js
var require_dezalgo = __commonJS({
  "node_modules/dezalgo/dezalgo.js"(exports, module) {
    var wrappy = require_wrappy();
    module.exports = wrappy(dezalgo);
    var asap = require_browser_asap();
    function dezalgo(cb) {
      var sync = true;
      asap(function() {
        sync = false;
      });
      return function zalgoSafe() {
        var args = arguments;
        var me = this;
        if (sync)
          asap(function() {
            cb.apply(me, args);
          });
        else
          cb.apply(me, args);
      };
    }
  }
});

// node_modules/formidable/src/parsers/Dummy.js
var require_Dummy = __commonJS({
  "node_modules/formidable/src/parsers/Dummy.js"(exports, module) {
    "use strict";
    var { Transform } = require_stream();
    var DummyParser = class extends Transform {
      constructor(incomingForm, options = {}) {
        super();
        this.globalOptions = { ...options };
        this.incomingForm = incomingForm;
      }
      _flush(callback) {
        this.incomingForm.ended = true;
        this.incomingForm._maybeEnd();
        callback();
      }
    };
    module.exports = DummyParser;
  }
});

// node_modules/formidable/src/FormidableError.js
var require_FormidableError = __commonJS({
  "node_modules/formidable/src/FormidableError.js"(exports, module) {
    var missingPlugin = 1e3;
    var pluginFunction = 1001;
    var aborted = 1002;
    var noParser = 1003;
    var uninitializedParser = 1004;
    var filenameNotString = 1005;
    var maxFieldsSizeExceeded = 1006;
    var maxFieldsExceeded = 1007;
    var smallerThanMinFileSize = 1008;
    var biggerThanMaxFileSize = 1009;
    var noEmptyFiles = 1010;
    var missingContentType = 1011;
    var malformedMultipart = 1012;
    var missingMultipartBoundary = 1013;
    var unknownTransferEncoding = 1014;
    var FormidableError = class extends Error {
      constructor(message, internalCode, httpCode = 500) {
        super(message);
        this.code = internalCode;
        this.httpCode = httpCode;
      }
    };
    module.exports = {
      missingPlugin,
      pluginFunction,
      aborted,
      noParser,
      uninitializedParser,
      filenameNotString,
      maxFieldsSizeExceeded,
      maxFieldsExceeded,
      smallerThanMinFileSize,
      biggerThanMaxFileSize,
      noEmptyFiles,
      missingContentType,
      malformedMultipart,
      missingMultipartBoundary,
      unknownTransferEncoding,
      FormidableError
    };
  }
});

// node_modules/formidable/src/parsers/Multipart.js
var require_Multipart = __commonJS({
  "node_modules/formidable/src/parsers/Multipart.js"(exports, module) {
    "use strict";
    var { Transform } = require_stream();
    var errors = require_FormidableError();
    var { FormidableError } = errors;
    var s = 0;
    var STATE = {
      PARSER_UNINITIALIZED: s++,
      START: s++,
      START_BOUNDARY: s++,
      HEADER_FIELD_START: s++,
      HEADER_FIELD: s++,
      HEADER_VALUE_START: s++,
      HEADER_VALUE: s++,
      HEADER_VALUE_ALMOST_DONE: s++,
      HEADERS_ALMOST_DONE: s++,
      PART_DATA_START: s++,
      PART_DATA: s++,
      PART_END: s++,
      END: s++
    };
    var f = 1;
    var FBOUNDARY = { PART_BOUNDARY: f, LAST_BOUNDARY: f *= 2 };
    var LF = 10;
    var CR = 13;
    var SPACE = 32;
    var HYPHEN = 45;
    var COLON = 58;
    var A = 97;
    var Z = 122;
    function lower(c) {
      return c | 32;
    }
    exports.STATES = {};
    Object.keys(STATE).forEach((stateName) => {
      exports.STATES[stateName] = STATE[stateName];
    });
    var MultipartParser = class extends Transform {
      constructor(options = {}) {
        super({ readableObjectMode: true });
        this.boundary = null;
        this.boundaryChars = null;
        this.lookbehind = null;
        this.bufferLength = 0;
        this.state = STATE.PARSER_UNINITIALIZED;
        this.globalOptions = { ...options };
        this.index = null;
        this.flags = 0;
      }
      _flush(done) {
        if (this.state === STATE.HEADER_FIELD_START && this.index === 0 || this.state === STATE.PART_DATA && this.index === this.boundary.length) {
          this._handleCallback("partEnd");
          this._handleCallback("end");
          done();
        } else if (this.state !== STATE.END) {
          done(
            new FormidableError(
              `MultipartParser.end(): stream ended unexpectedly: ${this.explain()}`,
              errors.malformedMultipart,
              400
            )
          );
        }
      }
      initWithBoundary(str) {
        this.boundary = Buffer.from(`\r
--${str}`);
        this.lookbehind = Buffer.alloc(this.boundary.length + 8);
        this.state = STATE.START;
        this.boundaryChars = {};
        for (let i = 0; i < this.boundary.length; i++) {
          this.boundaryChars[this.boundary[i]] = true;
        }
      }
      // eslint-disable-next-line max-params
      _handleCallback(name, buf, start, end) {
        if (start !== void 0 && start === end) {
          return;
        }
        this.push({ name, buffer: buf, start, end });
      }
      // eslint-disable-next-line max-statements
      _transform(buffer, _, done) {
        let i = 0;
        let prevIndex = this.index;
        let { index, state, flags } = this;
        const { lookbehind, boundary, boundaryChars } = this;
        const boundaryLength = boundary.length;
        const boundaryEnd = boundaryLength - 1;
        this.bufferLength = buffer.length;
        let c = null;
        let cl = null;
        const setMark = (name, idx) => {
          this[`${name}Mark`] = typeof idx === "number" ? idx : i;
        };
        const clearMarkSymbol = (name) => {
          delete this[`${name}Mark`];
        };
        const dataCallback = (name, shouldClear) => {
          const markSymbol = `${name}Mark`;
          if (!(markSymbol in this)) {
            return;
          }
          if (!shouldClear) {
            this._handleCallback(name, buffer, this[markSymbol], buffer.length);
            setMark(name, 0);
          } else {
            this._handleCallback(name, buffer, this[markSymbol], i);
            clearMarkSymbol(name);
          }
        };
        for (i = 0; i < this.bufferLength; i++) {
          c = buffer[i];
          switch (state) {
            case STATE.PARSER_UNINITIALIZED:
              return i;
            case STATE.START:
              index = 0;
              state = STATE.START_BOUNDARY;
            case STATE.START_BOUNDARY:
              if (index === boundary.length - 2) {
                if (c === HYPHEN) {
                  flags |= FBOUNDARY.LAST_BOUNDARY;
                } else if (c !== CR) {
                  return i;
                }
                index++;
                break;
              } else if (index - 1 === boundary.length - 2) {
                if (flags & FBOUNDARY.LAST_BOUNDARY && c === HYPHEN) {
                  this._handleCallback("end");
                  state = STATE.END;
                  flags = 0;
                } else if (!(flags & FBOUNDARY.LAST_BOUNDARY) && c === LF) {
                  index = 0;
                  this._handleCallback("partBegin");
                  state = STATE.HEADER_FIELD_START;
                } else {
                  return i;
                }
                break;
              }
              if (c !== boundary[index + 2]) {
                index = -2;
              }
              if (c === boundary[index + 2]) {
                index++;
              }
              break;
            case STATE.HEADER_FIELD_START:
              state = STATE.HEADER_FIELD;
              setMark("headerField");
              index = 0;
            case STATE.HEADER_FIELD:
              if (c === CR) {
                clearMarkSymbol("headerField");
                state = STATE.HEADERS_ALMOST_DONE;
                break;
              }
              index++;
              if (c === HYPHEN) {
                break;
              }
              if (c === COLON) {
                if (index === 1) {
                  return i;
                }
                dataCallback("headerField", true);
                state = STATE.HEADER_VALUE_START;
                break;
              }
              cl = lower(c);
              if (cl < A || cl > Z) {
                return i;
              }
              break;
            case STATE.HEADER_VALUE_START:
              if (c === SPACE) {
                break;
              }
              setMark("headerValue");
              state = STATE.HEADER_VALUE;
            case STATE.HEADER_VALUE:
              if (c === CR) {
                dataCallback("headerValue", true);
                this._handleCallback("headerEnd");
                state = STATE.HEADER_VALUE_ALMOST_DONE;
              }
              break;
            case STATE.HEADER_VALUE_ALMOST_DONE:
              if (c !== LF) {
                return i;
              }
              state = STATE.HEADER_FIELD_START;
              break;
            case STATE.HEADERS_ALMOST_DONE:
              if (c !== LF) {
                return i;
              }
              this._handleCallback("headersEnd");
              state = STATE.PART_DATA_START;
              break;
            case STATE.PART_DATA_START:
              state = STATE.PART_DATA;
              setMark("partData");
            case STATE.PART_DATA:
              prevIndex = index;
              if (index === 0) {
                i += boundaryEnd;
                while (i < this.bufferLength && !(buffer[i] in boundaryChars)) {
                  i += boundaryLength;
                }
                i -= boundaryEnd;
                c = buffer[i];
              }
              if (index < boundary.length) {
                if (boundary[index] === c) {
                  if (index === 0) {
                    dataCallback("partData", true);
                  }
                  index++;
                } else {
                  index = 0;
                }
              } else if (index === boundary.length) {
                index++;
                if (c === CR) {
                  flags |= FBOUNDARY.PART_BOUNDARY;
                } else if (c === HYPHEN) {
                  flags |= FBOUNDARY.LAST_BOUNDARY;
                } else {
                  index = 0;
                }
              } else if (index - 1 === boundary.length) {
                if (flags & FBOUNDARY.PART_BOUNDARY) {
                  index = 0;
                  if (c === LF) {
                    flags &= ~FBOUNDARY.PART_BOUNDARY;
                    this._handleCallback("partEnd");
                    this._handleCallback("partBegin");
                    state = STATE.HEADER_FIELD_START;
                    break;
                  }
                } else if (flags & FBOUNDARY.LAST_BOUNDARY) {
                  if (c === HYPHEN) {
                    this._handleCallback("partEnd");
                    this._handleCallback("end");
                    state = STATE.END;
                    flags = 0;
                  } else {
                    index = 0;
                  }
                } else {
                  index = 0;
                }
              }
              if (index > 0) {
                lookbehind[index - 1] = c;
              } else if (prevIndex > 0) {
                this._handleCallback("partData", lookbehind, 0, prevIndex);
                prevIndex = 0;
                setMark("partData");
                i--;
              }
              break;
            case STATE.END:
              break;
            default:
              return i;
          }
        }
        dataCallback("headerField");
        dataCallback("headerValue");
        dataCallback("partData");
        this.index = index;
        this.state = state;
        this.flags = flags;
        done();
        return this.bufferLength;
      }
      explain() {
        return `state = ${MultipartParser.stateToString(this.state)}`;
      }
    };
    MultipartParser.stateToString = (stateNumber) => {
      for (const stateName in STATE) {
        const number = STATE[stateName];
        if (number === stateNumber)
          return stateName;
      }
    };
    module.exports = Object.assign(MultipartParser, { STATES: exports.STATES });
  }
});

// node_modules/formidable/src/Formidable.js
var require_Formidable = __commonJS({
  "node_modules/formidable/src/Formidable.js"(exports, module) {
    "use strict";
    var os = require_os();
    var path = require_path();
    var hexoid = (init_dist(), __toCommonJS(dist_exports));
    var once = require_once();
    var dezalgo = require_dezalgo();
    var { EventEmitter } = require_events();
    var { StringDecoder } = require_string_decoder();
    var qs = require_lib();
    var toHexoId = hexoid(25);
    var DEFAULT_OPTIONS = {
      maxFields: 1e3,
      maxFieldsSize: 20 * 1024 * 1024,
      maxFileSize: 200 * 1024 * 1024,
      minFileSize: 1,
      allowEmptyFiles: true,
      keepExtensions: false,
      encoding: "utf-8",
      hashAlgorithm: false,
      uploadDir: os.tmpdir(),
      multiples: false,
      enabledPlugins: ["octetstream", "querystring", "multipart", "json"],
      fileWriteStreamHandler: null,
      defaultInvalidName: "invalid-name",
      filter: function() {
        return true;
      }
    };
    var PersistentFile = require_PersistentFile();
    var VolatileFile = require_VolatileFile();
    var DummyParser = require_Dummy();
    var MultipartParser = require_Multipart();
    var errors = require_FormidableError();
    var { FormidableError } = errors;
    function hasOwnProp(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    var IncomingForm = class extends EventEmitter {
      constructor(options = {}) {
        super();
        this.options = { ...DEFAULT_OPTIONS, ...options };
        const dir = path.resolve(
          this.options.uploadDir || this.options.uploaddir || os.tmpdir()
        );
        this.uploaddir = dir;
        this.uploadDir = dir;
        [
          "error",
          "headers",
          "type",
          "bytesExpected",
          "bytesReceived",
          "_parser"
        ].forEach((key) => {
          this[key] = null;
        });
        this._setUpRename();
        this._flushing = 0;
        this._fieldsSize = 0;
        this._fileSize = 0;
        this._plugins = [];
        this.openedFiles = [];
        this.options.enabledPlugins = [].concat(this.options.enabledPlugins).filter(Boolean);
        if (this.options.enabledPlugins.length === 0) {
          throw new FormidableError(
            "expect at least 1 enabled builtin plugin, see options.enabledPlugins",
            errors.missingPlugin
          );
        }
        this.options.enabledPlugins.forEach((pluginName) => {
          const plgName = pluginName.toLowerCase();
          this.use(__require(path.join(__dirname, "plugins", `${plgName}.js`)));
        });
        this._setUpMaxFields();
      }
      use(plugin) {
        if (typeof plugin !== "function") {
          throw new FormidableError(
            ".use: expect `plugin` to be a function",
            errors.pluginFunction
          );
        }
        this._plugins.push(plugin.bind(this));
        return this;
      }
      parse(req, cb) {
        this.pause = () => {
          try {
            req.pause();
          } catch (err) {
            if (!this.ended) {
              this._error(err);
            }
            return false;
          }
          return true;
        };
        this.resume = () => {
          try {
            req.resume();
          } catch (err) {
            if (!this.ended) {
              this._error(err);
            }
            return false;
          }
          return true;
        };
        if (cb) {
          const callback = once(dezalgo(cb));
          const fields = {};
          let mockFields = "";
          const files = {};
          this.on("field", (name, value) => {
            if (this.options.multiples && (this.type === "multipart" || this.type === "urlencoded")) {
              const mObj = { [name]: value };
              mockFields = mockFields ? `${mockFields}&${qs.stringify(mObj)}` : `${qs.stringify(mObj)}`;
            } else {
              fields[name] = value;
            }
          });
          this.on("file", (name, file) => {
            if (this.options.multiples) {
              if (hasOwnProp(files, name)) {
                if (!Array.isArray(files[name])) {
                  files[name] = [files[name]];
                }
                files[name].push(file);
              } else {
                files[name] = file;
              }
            } else {
              files[name] = file;
            }
          });
          this.on("error", (err) => {
            callback(err, fields, files);
          });
          this.on("end", () => {
            if (this.options.multiples) {
              Object.assign(fields, qs.parse(mockFields));
            }
            callback(null, fields, files);
          });
        }
        this.writeHeaders(req.headers);
        req.on("error", (err) => {
          this._error(err);
        }).on("aborted", () => {
          this.emit("aborted");
          this._error(new FormidableError("Request aborted", errors.aborted));
        }).on("data", (buffer) => {
          try {
            this.write(buffer);
          } catch (err) {
            this._error(err);
          }
        }).on("end", () => {
          if (this.error) {
            return;
          }
          if (this._parser) {
            this._parser.end();
          }
          this._maybeEnd();
        });
        return this;
      }
      writeHeaders(headers) {
        this.headers = headers;
        this._parseContentLength();
        this._parseContentType();
        if (!this._parser) {
          this._error(
            new FormidableError(
              "no parser found",
              errors.noParser,
              415
              // Unsupported Media Type
            )
          );
          return;
        }
        this._parser.once("error", (error) => {
          this._error(error);
        });
      }
      write(buffer) {
        if (this.error) {
          return null;
        }
        if (!this._parser) {
          this._error(
            new FormidableError("uninitialized parser", errors.uninitializedParser)
          );
          return null;
        }
        this.bytesReceived += buffer.length;
        this.emit("progress", this.bytesReceived, this.bytesExpected);
        this._parser.write(buffer);
        return this.bytesReceived;
      }
      pause() {
        return false;
      }
      resume() {
        return false;
      }
      onPart(part) {
        this._handlePart(part);
      }
      _handlePart(part) {
        if (part.originalFilename && typeof part.originalFilename !== "string") {
          this._error(
            new FormidableError(
              `the part.originalFilename should be string when it exists`,
              errors.filenameNotString
            )
          );
          return;
        }
        if (!part.mimetype) {
          let value = "";
          const decoder = new StringDecoder(
            part.transferEncoding || this.options.encoding
          );
          part.on("data", (buffer) => {
            this._fieldsSize += buffer.length;
            if (this._fieldsSize > this.options.maxFieldsSize) {
              this._error(
                new FormidableError(
                  `options.maxFieldsSize (${this.options.maxFieldsSize} bytes) exceeded, received ${this._fieldsSize} bytes of field data`,
                  errors.maxFieldsSizeExceeded,
                  413
                  // Payload Too Large
                )
              );
              return;
            }
            value += decoder.write(buffer);
          });
          part.on("end", () => {
            this.emit("field", part.name, value);
          });
          return;
        }
        if (!this.options.filter(part)) {
          return;
        }
        this._flushing += 1;
        const newFilename = this._getNewName(part);
        const filepath = this._joinDirectoryName(newFilename);
        const file = this._newFile({
          newFilename,
          filepath,
          originalFilename: part.originalFilename,
          mimetype: part.mimetype
        });
        file.on("error", (err) => {
          this._error(err);
        });
        this.emit("fileBegin", part.name, file);
        file.open();
        this.openedFiles.push(file);
        part.on("data", (buffer) => {
          this._fileSize += buffer.length;
          if (this._fileSize < this.options.minFileSize) {
            this._error(
              new FormidableError(
                `options.minFileSize (${this.options.minFileSize} bytes) inferior, received ${this._fileSize} bytes of file data`,
                errors.smallerThanMinFileSize,
                400
              )
            );
            return;
          }
          if (this._fileSize > this.options.maxFileSize) {
            this._error(
              new FormidableError(
                `options.maxFileSize (${this.options.maxFileSize} bytes) exceeded, received ${this._fileSize} bytes of file data`,
                errors.biggerThanMaxFileSize,
                413
              )
            );
            return;
          }
          if (buffer.length === 0) {
            return;
          }
          this.pause();
          file.write(buffer, () => {
            this.resume();
          });
        });
        part.on("end", () => {
          if (!this.options.allowEmptyFiles && this._fileSize === 0) {
            this._error(
              new FormidableError(
                `options.allowEmptyFiles is false, file size should be greather than 0`,
                errors.noEmptyFiles,
                400
              )
            );
            return;
          }
          file.end(() => {
            this._flushing -= 1;
            this.emit("file", part.name, file);
            this._maybeEnd();
          });
        });
      }
      // eslint-disable-next-line max-statements
      _parseContentType() {
        if (this.bytesExpected === 0) {
          this._parser = new DummyParser(this, this.options);
          return;
        }
        if (!this.headers["content-type"]) {
          this._error(
            new FormidableError(
              "bad content-type header, no content-type",
              errors.missingContentType,
              400
            )
          );
          return;
        }
        const results = [];
        const _dummyParser = new DummyParser(this, this.options);
        for (let idx = 0; idx < this._plugins.length; idx++) {
          const plugin = this._plugins[idx];
          let pluginReturn = null;
          try {
            pluginReturn = plugin(this, this.options) || this;
          } catch (err) {
            const error = new FormidableError(
              `plugin on index ${idx} failed with: ${err.message}`,
              errors.pluginFailed,
              500
            );
            error.idx = idx;
            throw error;
          }
          Object.assign(this, pluginReturn);
          this.emit("plugin", idx, pluginReturn);
          results.push(pluginReturn);
        }
        this.emit("pluginsResults", results);
      }
      _error(err, eventName = "error") {
        if (this.error || this.ended) {
          return;
        }
        this.error = err;
        this.emit(eventName, err);
        if (Array.isArray(this.openedFiles)) {
          this.openedFiles.forEach((file) => {
            file.destroy();
          });
        }
      }
      _parseContentLength() {
        this.bytesReceived = 0;
        if (this.headers["content-length"]) {
          this.bytesExpected = parseInt(this.headers["content-length"], 10);
        } else if (this.headers["transfer-encoding"] === void 0) {
          this.bytesExpected = 0;
        }
        if (this.bytesExpected !== null) {
          this.emit("progress", this.bytesReceived, this.bytesExpected);
        }
      }
      _newParser() {
        return new MultipartParser(this.options);
      }
      _newFile({ filepath, originalFilename, mimetype, newFilename }) {
        return this.options.fileWriteStreamHandler ? new VolatileFile({
          newFilename,
          filepath,
          originalFilename,
          mimetype,
          createFileWriteStream: this.options.fileWriteStreamHandler,
          hashAlgorithm: this.options.hashAlgorithm
        }) : new PersistentFile({
          newFilename,
          filepath,
          originalFilename,
          mimetype,
          hashAlgorithm: this.options.hashAlgorithm
        });
      }
      _getFileName(headerValue) {
        const m = headerValue.match(
          /\bfilename=("(.*?)"|([^()<>{}[\]@,;:"?=\s/\t]+))($|;\s)/i
        );
        if (!m)
          return null;
        const match = m[2] || m[3] || "";
        let originalFilename = match.substr(match.lastIndexOf("\\") + 1);
        originalFilename = originalFilename.replace(/%22/g, '"');
        originalFilename = originalFilename.replace(
          /&#([\d]{4});/g,
          (_, code) => String.fromCharCode(code)
        );
        return originalFilename;
      }
      _getExtension(str) {
        if (!str) {
          return "";
        }
        const basename = path.basename(str);
        const firstDot = basename.indexOf(".");
        const lastDot = basename.lastIndexOf(".");
        const extname = path.extname(basename).replace(/(\.[a-z0-9]+).*/i, "$1");
        if (firstDot === lastDot) {
          return extname;
        }
        return basename.slice(firstDot, lastDot) + extname;
      }
      _joinDirectoryName(name) {
        const newPath = path.join(this.uploadDir, name);
        if (!newPath.startsWith(this.uploadDir)) {
          return path.join(this.uploadDir, this.options.defaultInvalidName);
        }
        return newPath;
      }
      _setUpRename() {
        const hasRename = typeof this.options.filename === "function";
        if (hasRename) {
          this._getNewName = (part) => {
            let ext = "";
            let name = this.options.defaultInvalidName;
            if (part.originalFilename) {
              ({ ext, name } = path.parse(part.originalFilename));
              if (this.options.keepExtensions !== true) {
                ext = "";
              }
            }
            return this.options.filename.call(this, name, ext, part, this);
          };
        } else {
          this._getNewName = (part) => {
            const name = toHexoId();
            if (part && this.options.keepExtensions) {
              const originalFilename = typeof part === "string" ? part : part.originalFilename;
              return `${name}${this._getExtension(originalFilename)}`;
            }
            return name;
          };
        }
      }
      _setUpMaxFields() {
        if (this.options.maxFields !== 0) {
          let fieldsCount = 0;
          this.on("field", () => {
            fieldsCount += 1;
            if (fieldsCount > this.options.maxFields) {
              this._error(
                new FormidableError(
                  `options.maxFields (${this.options.maxFields}) exceeded`,
                  errors.maxFieldsExceeded,
                  413
                )
              );
            }
          });
        }
      }
      _maybeEnd() {
        if (!this.ended || this._flushing || this.error) {
          return;
        }
        this.emit("end");
      }
    };
    IncomingForm.DEFAULT_OPTIONS = DEFAULT_OPTIONS;
    module.exports = IncomingForm;
  }
});

// node_modules/formidable/src/parsers/OctetStream.js
var require_OctetStream = __commonJS({
  "node_modules/formidable/src/parsers/OctetStream.js"(exports, module) {
    "use strict";
    var { PassThrough } = require_stream();
    var OctetStreamParser = class extends PassThrough {
      constructor(options = {}) {
        super();
        this.globalOptions = { ...options };
      }
    };
    module.exports = OctetStreamParser;
  }
});

// node_modules/formidable/src/plugins/octetstream.js
var require_octetstream = __commonJS({
  "node_modules/formidable/src/plugins/octetstream.js"(exports, module) {
    "use strict";
    var OctetStreamParser = require_OctetStream();
    module.exports = function plugin(formidable, options) {
      const self2 = this || formidable;
      if (/octet-stream/i.test(self2.headers["content-type"])) {
        init.call(self2, self2, options);
      }
      return self2;
    };
    function init(_self, _opts) {
      this.type = "octet-stream";
      const originalFilename = this.headers["x-file-name"];
      const mimetype = this.headers["content-type"];
      const thisPart = {
        originalFilename,
        mimetype
      };
      const newFilename = this._getNewName(thisPart);
      const filepath = this._joinDirectoryName(newFilename);
      const file = this._newFile({
        newFilename,
        filepath,
        originalFilename,
        mimetype
      });
      this.emit("fileBegin", originalFilename, file);
      file.open();
      this.openedFiles.push(file);
      this._flushing += 1;
      this._parser = new OctetStreamParser(this.options);
      let outstandingWrites = 0;
      this._parser.on("data", (buffer) => {
        this.pause();
        outstandingWrites += 1;
        file.write(buffer, () => {
          outstandingWrites -= 1;
          this.resume();
          if (this.ended) {
            this._parser.emit("doneWritingFile");
          }
        });
      });
      this._parser.on("end", () => {
        this._flushing -= 1;
        this.ended = true;
        const done = () => {
          file.end(() => {
            this.emit("file", "file", file);
            this._maybeEnd();
          });
        };
        if (outstandingWrites === 0) {
          done();
        } else {
          this._parser.once("doneWritingFile", done);
        }
      });
      return this;
    }
  }
});

// node_modules/formidable/src/parsers/Querystring.js
var require_Querystring = __commonJS({
  "node_modules/formidable/src/parsers/Querystring.js"(exports, module) {
    "use strict";
    var { Transform } = require_stream();
    var querystring = require_querystring();
    var QuerystringParser = class extends Transform {
      constructor(options = {}) {
        super({ readableObjectMode: true });
        this.globalOptions = { ...options };
        this.buffer = "";
        this.bufferLength = 0;
      }
      _transform(buffer, encoding, callback) {
        this.buffer += buffer.toString("ascii");
        this.bufferLength = this.buffer.length;
        callback();
      }
      _flush(callback) {
        const fields = querystring.parse(this.buffer, "&", "=");
        for (const key in fields) {
          this.push({
            key,
            value: fields[key]
          });
        }
        this.buffer = "";
        callback();
      }
    };
    module.exports = QuerystringParser;
  }
});

// node_modules/formidable/src/plugins/querystring.js
var require_querystring2 = __commonJS({
  "node_modules/formidable/src/plugins/querystring.js"(exports, module) {
    "use strict";
    var QuerystringParser = require_Querystring();
    module.exports = function plugin(formidable, options) {
      const self2 = this || formidable;
      if (/urlencoded/i.test(self2.headers["content-type"])) {
        init.call(self2, self2, options);
      }
      return self2;
    };
    function init(_self, _opts) {
      this.type = "urlencoded";
      const parser = new QuerystringParser(this.options);
      parser.on("data", ({ key, value }) => {
        this.emit("field", key, value);
      });
      parser.once("end", () => {
        this.ended = true;
        this._maybeEnd();
      });
      this._parser = parser;
      return this;
    }
  }
});

// node_modules/formidable/src/plugins/multipart.js
var require_multipart = __commonJS({
  "node_modules/formidable/src/plugins/multipart.js"(exports, module) {
    "use strict";
    var { Stream } = require_stream();
    var MultipartParser = require_Multipart();
    var errors = require_FormidableError();
    var { FormidableError } = errors;
    module.exports = function plugin(formidable, options) {
      const self2 = this || formidable;
      const multipart = /multipart/i.test(self2.headers["content-type"]);
      if (multipart) {
        const m = self2.headers["content-type"].match(
          /boundary=(?:"([^"]+)"|([^;]+))/i
        );
        if (m) {
          const initMultipart = createInitMultipart(m[1] || m[2]);
          initMultipart.call(self2, self2, options);
        } else {
          const err = new FormidableError(
            "bad content-type header, no multipart boundary",
            errors.missingMultipartBoundary,
            400
          );
          self2._error(err);
        }
      }
    };
    function createInitMultipart(boundary) {
      return function initMultipart() {
        this.type = "multipart";
        const parser = new MultipartParser(this.options);
        let headerField;
        let headerValue;
        let part;
        parser.initWithBoundary(boundary);
        parser.on("data", ({ name, buffer, start, end }) => {
          if (name === "partBegin") {
            part = new Stream();
            part.readable = true;
            part.headers = {};
            part.name = null;
            part.originalFilename = null;
            part.mimetype = null;
            part.transferEncoding = this.options.encoding;
            part.transferBuffer = "";
            headerField = "";
            headerValue = "";
          } else if (name === "headerField") {
            headerField += buffer.toString(this.options.encoding, start, end);
          } else if (name === "headerValue") {
            headerValue += buffer.toString(this.options.encoding, start, end);
          } else if (name === "headerEnd") {
            headerField = headerField.toLowerCase();
            part.headers[headerField] = headerValue;
            const m = headerValue.match(
              // eslint-disable-next-line no-useless-escape
              /\bname=("([^"]*)"|([^\(\)<>@,;:\\"\/\[\]\?=\{\}\s\t/]+))/i
            );
            if (headerField === "content-disposition") {
              if (m) {
                part.name = m[2] || m[3] || "";
              }
              part.originalFilename = this._getFileName(headerValue);
            } else if (headerField === "content-type") {
              part.mimetype = headerValue;
            } else if (headerField === "content-transfer-encoding") {
              part.transferEncoding = headerValue.toLowerCase();
            }
            headerField = "";
            headerValue = "";
          } else if (name === "headersEnd") {
            switch (part.transferEncoding) {
              case "binary":
              case "7bit":
              case "8bit":
              case "utf-8": {
                const dataPropagation = (ctx) => {
                  if (ctx.name === "partData") {
                    part.emit("data", ctx.buffer.slice(ctx.start, ctx.end));
                  }
                };
                const dataStopPropagation = (ctx) => {
                  if (ctx.name === "partEnd") {
                    part.emit("end");
                    parser.off("data", dataPropagation);
                    parser.off("data", dataStopPropagation);
                  }
                };
                parser.on("data", dataPropagation);
                parser.on("data", dataStopPropagation);
                break;
              }
              case "base64": {
                const dataPropagation = (ctx) => {
                  if (ctx.name === "partData") {
                    part.transferBuffer += ctx.buffer.slice(ctx.start, ctx.end).toString("ascii");
                    const offset = parseInt(part.transferBuffer.length / 4, 10) * 4;
                    part.emit(
                      "data",
                      Buffer.from(
                        part.transferBuffer.substring(0, offset),
                        "base64"
                      )
                    );
                    part.transferBuffer = part.transferBuffer.substring(offset);
                  }
                };
                const dataStopPropagation = (ctx) => {
                  if (ctx.name === "partEnd") {
                    part.emit("data", Buffer.from(part.transferBuffer, "base64"));
                    part.emit("end");
                    parser.off("data", dataPropagation);
                    parser.off("data", dataStopPropagation);
                  }
                };
                parser.on("data", dataPropagation);
                parser.on("data", dataStopPropagation);
                break;
              }
              default:
                return this._error(
                  new FormidableError(
                    "unknown transfer-encoding",
                    errors.unknownTransferEncoding,
                    501
                  )
                );
            }
            this.onPart(part);
          } else if (name === "end") {
            this.ended = true;
            this._maybeEnd();
          }
        });
        this._parser = parser;
      };
    }
  }
});

// node_modules/formidable/src/parsers/JSON.js
var require_JSON = __commonJS({
  "node_modules/formidable/src/parsers/JSON.js"(exports, module) {
    "use strict";
    var { Transform } = require_stream();
    var JSONParser = class extends Transform {
      constructor(options = {}) {
        super({ readableObjectMode: true });
        this.chunks = [];
        this.globalOptions = { ...options };
      }
      _transform(chunk, encoding, callback) {
        this.chunks.push(String(chunk));
        callback();
      }
      _flush(callback) {
        try {
          const fields = JSON.parse(this.chunks.join(""));
          Object.keys(fields).forEach((key) => {
            const value = fields[key];
            this.push({ key, value });
          });
        } catch (e) {
          callback(e);
          return;
        }
        this.chunks = null;
        callback();
      }
    };
    module.exports = JSONParser;
  }
});

// node_modules/formidable/src/plugins/json.js
var require_json = __commonJS({
  "node_modules/formidable/src/plugins/json.js"(exports, module) {
    "use strict";
    var JSONParser = require_JSON();
    module.exports = function plugin(formidable, options) {
      const self2 = this || formidable;
      if (/json/i.test(self2.headers["content-type"])) {
        init.call(self2, self2, options);
      }
    };
    function init(_self, _opts) {
      this.type = "json";
      const parser = new JSONParser(this.options);
      parser.on("data", ({ key, value }) => {
        this.emit("field", key, value);
      });
      parser.once("end", () => {
        this.ended = true;
        this._maybeEnd();
      });
      this._parser = parser;
    }
  }
});

// node_modules/formidable/src/plugins/index.js
var require_plugins = __commonJS({
  "node_modules/formidable/src/plugins/index.js"(exports) {
    "use strict";
    var octetstream = require_octetstream();
    var querystring = require_querystring2();
    var multipart = require_multipart();
    var json = require_json();
    Object.assign(exports, {
      octetstream,
      querystring,
      multipart,
      json
    });
  }
});

// node_modules/formidable/src/parsers/index.js
var require_parsers = __commonJS({
  "node_modules/formidable/src/parsers/index.js"(exports) {
    "use strict";
    var JSONParser = require_JSON();
    var DummyParser = require_Dummy();
    var MultipartParser = require_Multipart();
    var OctetStreamParser = require_OctetStream();
    var QueryStringParser = require_Querystring();
    Object.assign(exports, {
      JSONParser,
      DummyParser,
      MultipartParser,
      OctetStreamParser,
      OctetstreamParser: OctetStreamParser,
      QueryStringParser,
      QuerystringParser: QueryStringParser
    });
  }
});

// node_modules/formidable/src/index.js
var require_src = __commonJS({
  "node_modules/formidable/src/index.js"(exports, module) {
    var PersistentFile = require_PersistentFile();
    var VolatileFile = require_VolatileFile();
    var Formidable = require_Formidable();
    var FormidableError = require_FormidableError();
    var plugins = require_plugins();
    var parsers = require_parsers();
    var formidable = (...args) => new Formidable(...args);
    module.exports = Object.assign(formidable, {
      errors: FormidableError,
      File: PersistentFile,
      PersistentFile,
      VolatileFile,
      Formidable,
      formidable,
      // alias
      IncomingForm: Formidable,
      // parsers
      ...parsers,
      parsers,
      // misc
      defaultOptions: Formidable.DEFAULT_OPTIONS,
      enabledPlugins: Formidable.DEFAULT_OPTIONS.enabledPlugins,
      // plugins
      plugins: {
        ...plugins
      }
    });
  }
});
export default require_src();
//# sourceMappingURL=formidable.js.map
